{"meta":{"title":"Mr.zang 的博客","subtitle":null,"description":"Mr.zang 个人博客","author":"Mr.zang","url":"https://silencemrzang.github.io/MrZangBlog"},"pages":[{"title":"关于作者","date":"2019-08-10T02:24:47.796Z","updated":"2019-05-05T08:28:38.000Z","comments":true,"path":"about/index.html","permalink":"https://silencemrzang.github.io/MrZangBlog/about/index.html","excerpt":"","text":"Android 开发工程师前端小菜比 react react-native 栈热爱运动热爱音乐最爱打篮球 标准的科密坐标 中国 河南 郑州"},{"title":"类别","date":"2018-12-21T13:38:10.000Z","updated":"2019-03-07T10:03:16.000Z","comments":true,"path":"categories/index.html","permalink":"https://silencemrzang.github.io/MrZangBlog/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-12-21T13:37:34.000Z","updated":"2019-03-07T10:03:16.000Z","comments":true,"path":"tags/index.html","permalink":"https://silencemrzang.github.io/MrZangBlog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HashMap/SparseArray","slug":"HashMap-SparseArray","date":"2019-08-19T12:23:04.000Z","updated":"2019-08-19T12:37:47.763Z","comments":true,"path":"2019/08/19/HashMap-SparseArray/","link":"","permalink":"https://silencemrzang.github.io/MrZangBlog/2019/08/19/HashMap-SparseArray/","excerpt":"","text":"存储 key / value 键值对值 在Java 中常用的是 HashMap 但是Android 对内存的要求是很高的 一切消耗内存的操作都应该避免 HashMap 存储模式是哈希表 {数组+链表} 实践证明HashMap 在存储 key/vlue 值 在Android上消耗 内存比较严重 特别是大量存储 删除的时候 为了避免这一问题 Android 在Utils包里给我们提供了 SparseArray 类用来实现key/vlue 存储。。。 年轻司机带路 走一波。。。 # 为何HashMap 消耗内存比较大为何SparseArray会比HashMap更节省内存，这要从它们各自的结构说起。HashMap底层数据结构是一个 数组+链表 的组合（关于数组和链表的概念，这里就不多阐述了），它采用一种所谓的“Hash 算法”来决定每个元素的存储位置。当程序执行 map.put(key,Obect) 方法 时，系统将调用key对象的 hashCode() 方法得到其 hashCode 值（每个Java对象都有 hashCode() 方法，都可通过该方法获得它的 hashCode 值）。得到这个对象的 hashCode 值之后，系统会根据该 hashCode 值再hash一遍来决定该元素在数组中的存储位置。 但是这就存在一个问题，如果两个key算出来的hash值刚好相等，也就是存放的数组位置一样时，就产生了Hash冲突（因为原本数组的那个位置已经有一个元素存放着，而一个位置只能存放一组数据），那HashMap是怎么解决这种冲突的呢？HashMap采用链表法来解决Hash冲突，也就是说，如果发生这种情况，HashMap会在数组中冲突的那个位置，将后加入的元素指向原来占有数组位置的那个元素，从而追加形成一个链表 # 为何SparseArray 更为优化先了解一个基本概念——什么是自动装箱？自动装箱就是指自动将基本数据类型转换为包装器类型，比如下面这句代码： 1Interger = 99; 99是基本数据类型，将它直接赋值给Integer类型对象i时，就会自动将我们的基本类型int包装成Integer。装箱操作会创建对象，频繁的装箱操作会消耗许多内存，影响性能。 而SparseArray又称为稀疏数组，与HashMap不同，其内部是直接通过维护两个数组来实现存储 123456public class SparseArray&lt;E&gt; implements Cloneable &#123; private int[] mKeys; private Object[] mValues; ...&#125; 可以看到，一组存储键，一组存储值，key数组的类型是int型，也就是说，SparseArray只支持key为int类型的数据存储，关键就在这里，由于它是直接维护了一个int数组，那么key就避免了自动装箱的过程，举个例子，比如我们用HashMap存储下面这组数据： 1234HashMap&lt;Integer, String&gt; hashMap = new HashMap&lt;&gt;();hashMap.put(1, \"test\");hashMap.put(2, \"test\");hashMap.put(3, \"test\"); 每次put进去的时候，由于传进去的是1，2，3，都是int基本类型，HashMap会自动帮我们包装成Integer类型的对象（也就是刚说的自动装箱），那么就肯定会消耗更多内存。但如果是SparseArray来存储的话，就直接将key存储在key数组了，省去了装箱这个过程，从而节省了内存开销。另一方面，对SparseArray增删查改操作时，其内部会不断检查回收无用空间，从而压缩占用的内存大小，我们看下它的put方法： 123456789101112131415161718192021222324252627282930public void put(int key, E value) &#123; //先调用二分法查询该key在数组中的位置 int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &gt;= 0) &#123; //大于0说明已经存在数组中，可以直接赋值 mValues[i] = value; &#125; else &#123; //小于0说明这是一个新的键值对，且它应该插在数组中的第i个位置 i = ~i; //根据DELETED来查询当前位置的值是否已经被删除 if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123; mKeys[i] = key; mValues[i] = value; return; &#125; //如果当前容量已满 if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123; //回收无效空间 gc(); // Search again because indices may have changed. i = ~ContainerHelpers.binarySearch(mKeys, mSize, key); &#125; mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key); mValues = GrowingArrayUtils.insert(mValues, mSize, i, value); mSize++; &#125;&#125; 可以看到，SparseArray会先调用二分法去查询key应该存放在数组中的位置，所以SparseArray的key数组一定是有序排列的，然后会用一个DELETED来作为当前位置的元素是否已经被删除，DELETED会在调用remove移除元素的时候赋给对应位置Value，如下： 1234567891011121314public void remove(int key) &#123; delete(key);&#125;public void delete(int key) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &gt;= 0) &#123; if (mValues[i] != DELETED) &#123; mValues[i] = DELETED; mGarbage = true; &#125; &#125;&#125; SparseArray通过这个来作为它压缩空间的一个标志（即该位置可不可以被回收），这样子也进一步节省了空间。 从刚才可以看出，无论是SparseArray的put还是delete（其实其他操作比如get也都是通过二分法寻找下标），都是通过二分法去查询这个key应该被存放的位置。而HashMap在插入的时候，不需要去遍历整个集合，而是直接通过hash计算出位置插入。所以在插入效率上，SparseArray会比HashMap稍慢一些，但在数据量不大的情况下，两者的差别不大。 # 结语SparseArray与HashMap相比，最大的优势在于内存方面，无论数据量级大小如何，SparseArray所占用的内存都会比HashMap小，在Android中内存是极为重要的，所以在需要保存&lt;Integer,Object&gt;键值对的场景中，推荐使用SparseArray替换HashMap。换句话说，SparseArray是Android中为&lt;Integer,Object&gt;这样的HashMap专门写的类，它避开了自动装箱并且压缩稀疏数组，目的就是为了节省内存。另外，Android还提供了其他几种类似的集合类：SparseIntArray、SparseBooleanArray、SparseLongArray，可以支持存储&lt;Integer,Integer&gt;、&lt;Integer,Boolean&gt;、&lt;Integer,Long&gt;的数据类型，也就是同时让Value也避开了装箱过程，进一步优化。","categories":[{"name":"Android","slug":"Android","permalink":"https://silencemrzang.github.io/MrZangBlog/categories/Android/"},{"name":"Map","slug":"Android/Map","permalink":"https://silencemrzang.github.io/MrZangBlog/categories/Android/Map/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://silencemrzang.github.io/MrZangBlog/tags/Android/"},{"name":"Map","slug":"Map","permalink":"https://silencemrzang.github.io/MrZangBlog/tags/Map/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://silencemrzang.github.io/MrZangBlog/categories/Android/"},{"name":"Map","slug":"Android/Map","permalink":"https://silencemrzang.github.io/MrZangBlog/categories/Android/Map/"}]},{"title":"启动模式","slug":"启动模式","date":"2019-08-15T14:53:13.000Z","updated":"2019-08-15T14:54:04.100Z","comments":true,"path":"2019/08/15/启动模式/","link":"","permalink":"https://silencemrzang.github.io/MrZangBlog/2019/08/15/启动模式/","excerpt":"","text":"","categories":[{"name":"启动模式","slug":"启动模式","permalink":"https://silencemrzang.github.io/MrZangBlog/categories/启动模式/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://silencemrzang.github.io/MrZangBlog/tags/Android/"}],"keywords":[{"name":"启动模式","slug":"启动模式","permalink":"https://silencemrzang.github.io/MrZangBlog/categories/启动模式/"}]},{"title":"探究 Java Builder 模式","slug":"java_bulider","date":"2019-08-15T01:38:59.000Z","updated":"2019-08-15T15:03:01.370Z","comments":true,"path":"2019/08/15/java_bulider/","link":"","permalink":"https://silencemrzang.github.io/MrZangBlog/2019/08/15/java_bulider/","excerpt":"","text":"# Java 设计模式Builder 模式 Java Builder模式主要是用一个内部类去实例化一个对象，避免一个类出现过多构造函数，而且构造函数如果出现默认参数的话，很容易出错 Android Builder 模式 实践的第三方库 Glide 图片加载库 UCrop 图片裁剪 等 、、、 以UCrop 构建类 UCrop.java 为例 123456789UCrop.Options options = new UCrop.Options(); options.setHideBottomControls(true); options.setFreeStyleCropEnabled(clipBoxMove); //设置裁剪的图片质量，取值0-100 options.setCompressionQuality(compress); UCrop.of(Uri.parse(sourceFilePath), Uri.parse(outPutFilePath)) .withAspectRatio(scaleX, scaleY) .withOptions(options) .start(activity); 参数构造集 内部类 构造函数不对外开放 内部逻辑调用 123456private UCrop(@NonNull Uri source, @NonNull Uri destination) &#123; mCropIntent = new Intent(); mCropOptionsBundle = new Bundle(); mCropOptionsBundle.putParcelable(EXTRA_INPUT_URI, source); mCropOptionsBundle.putParcelable(EXTRA_OUTPUT_URI, destination);&#125; 公开 静态方法 供外部调用 12345678910/** * This method creates new Intent builder and sets both * source and destination image URIs. * * @param source Uri for image to crop * @param destination Uri for saving the cropped image */ public static UCrop of(@NonNull Uri source, @NonNull Uri destination) &#123; return new UCrop(source, destination); &#125; 参数集合 赋值给 Ucrop 构造类1234public UCrop withOptions(@NonNull Options options) &#123; mCropOptionsBundle.putAll(options.getOptionBundle()); return this; &#125; 1234567891011121314151617181920/** * Get Intent to start &#123;@link UCropActivity&#125; * * @return Intent for &#123;@link UCropActivity&#125; */ public Intent getIntent(@NonNull Context context) &#123; mCropIntent.setClass(context, UCropActivity.class); mCropIntent.putExtras(mCropOptionsBundle); return mCropIntent; &#125; /** * Send the crop Intent from an Activity with a custom request code * * @param activity Activity to receive result * @param requestCode requestCode for result */ public void start(@NonNull Activity activity, int requestCode) &#123; activity.startActivityForResult(getIntent(activity), requestCode); &#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://silencemrzang.github.io/MrZangBlog/categories/Android/"},{"name":"Java","slug":"Android/Java","permalink":"https://silencemrzang.github.io/MrZangBlog/categories/Android/Java/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://silencemrzang.github.io/MrZangBlog/tags/Android/"},{"name":"Builder","slug":"Builder","permalink":"https://silencemrzang.github.io/MrZangBlog/tags/Builder/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://silencemrzang.github.io/MrZangBlog/categories/Android/"},{"name":"Java","slug":"Android/Java","permalink":"https://silencemrzang.github.io/MrZangBlog/categories/Android/Java/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-08-08T09:30:57.050Z","updated":"2019-08-08T02:23:34.000Z","comments":true,"path":"2019/08/08/hello-world/","link":"","permalink":"https://silencemrzang.github.io/MrZangBlog/2019/08/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"flutter_02","slug":"flutter-02","date":"2019-08-08T07:05:26.000Z","updated":"2019-08-08T07:05:38.000Z","comments":true,"path":"2019/08/08/flutter-02/","link":"","permalink":"https://silencemrzang.github.io/MrZangBlog/2019/08/08/flutter-02/","excerpt":"","text":"","categories":[],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://silencemrzang.github.io/MrZangBlog/tags/flutter/"}],"keywords":[]},{"title":"flutter_01","slug":"flutter-01","date":"2019-08-08T07:03:05.000Z","updated":"2019-08-08T07:06:02.000Z","comments":true,"path":"2019/08/08/flutter-01/","link":"","permalink":"https://silencemrzang.github.io/MrZangBlog/2019/08/08/flutter-01/","excerpt":"","text":"","categories":[],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://silencemrzang.github.io/MrZangBlog/tags/flutter/"}],"keywords":[]},{"title":"hexo_init","slug":"hexo-init","date":"2019-08-08T07:00:54.000Z","updated":"2019-08-08T07:17:00.000Z","comments":true,"path":"2019/08/08/hexo-init/","link":"","permalink":"https://silencemrzang.github.io/MrZangBlog/2019/08/08/hexo-init/","excerpt":"","text":"# 搭建环境： 下载node install git npm –version npm install -g hexo-cli # 初始化： hexo init {your blog name} cd hexo {your blog name} npm install hexo server 本地运行查看 # 配置：12345678910111213141516171819202122232425262728# Sitetitle: xxxsubtitle:description: xxxkeywords:author: xxxlanguage: zh-Hans timezone:# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://xxxx.github.io/xxxx/ &#123;你要部署仓库的Page地址&#125;root: /xxxx/permalink: :year/:month/:day/:title/permalink_defaults:# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/xxxx/xxxx.git branch: master 123456789101112131415161718192021&#123; \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"hexo\": &#123; \"version\": \"3.9.0\" &#125;, \"dependencies\": &#123; \"hexo\": \"^3.9.0\", \"hexo-asset-image\": \"0.0.3\", \"hexo-generator-archive\": \"^0.1.5\", \"hexo-generator-category\": \"^0.1.3\", \"hexo-generator-index\": \"^0.2.1\", \"hexo-generator-tag\": \"^0.2.0\", \"hexo-renderer-ejs\": \"^0.3.1\", \"hexo-renderer-stylus\": \"^0.3.3\", \"hexo-renderer-marked\": \"^1.0.1\", \"hexo-deployer-git\": \"^0.3.1\", //git 包 \"hexo-server\": \"^0.3.3\" &#125;&#125; # hexo 命令 编译 hexo g 清除 hexo clean 运行 hexo s 提交仓库 hexo d","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://silencemrzang.github.io/MrZangBlog/tags/hexo/"}],"keywords":[]}]}